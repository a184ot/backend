

<details>
  <summary>1. Что такое ООП?</summary>

   `Методология, парадигма программирования, основной концепцией является понятие
   объекта` (объект отождествляется с предметной областью).
   Программа представлена, как совокупность объектов, каждый из которых является
   экземпляром определенного класса, а классы образуют иерархию наследования.
   
КЛАСС – это описание ещё не созданного объекта, общий шаблон.
   
Шаблон состоит из:
- полей (имя, возраст для чел. и т.д.). Состояние/ряд меняющихся свойств.
- конструктора (первоначально инициализирует объект, заполняет нужные поля)
- методов (что умеет делать объект). Действия, функции конкретного объекта.
  
ОБЪЕКТ – это экземпляр класса, созданный по шаблону (выше) с собственным
  состоянием свойств.

  Три составляющих каждого объекта:
  - идентичность (identity) – то, что отличает один объект класса от другого (equals)
  - состояние (state) - набор всех полей объекта и их значений
  - поведение (behaviour) - набор всех методов класса объекта
  
Программа считается ООП, только если выполнены ВСЕ ТРИ условия:
1. основные логические элементы программы – это объекты (а не алгоритмы)
2. каждый объект – это экземпляр класса
3. классы образуют иерархии
</details>

<details>
  <summary>2. Какие преимущества у ООП?</summary>

Делим программу на «модули»-классы, ОБЪЕКТЫ каждый из которых делает свою часть
работы.

Код можно повторно использовать в любом месте программы, это экономит время (не
нужно писать однотипные функции для разных сущностей).

«Более естественная» декомпозиция ПО существенно облегчает его разработку (код
легко читается и быстро пишется).

Возможность создавать расширяемые системы (extensible systems), именно это отличает
ООП от традиционных методов программирования.
</details>

<details>
  <summary>3. Какие недостатки у ООП?</summary>

Снижение производительности и увеличение потребления памяти по сравнению с
другими (процедурными) языками.

`Справка:` Большинство ранних императивных языков программирования - процедурные, в том числе Фортран, Кобол,
Алгол, Бейсик, Си, Паскаль, Форт. Более поздние императивные языки, в частности, реализующие ООП парадигму
C++, Java, как правило, НЕ относят к категории процедурных, поскольку принцип организации блоков выполнения
подпрограммы в них реализуется на другом уровне абстракции.

Почему так? ООП требует распределения информации по множеству мелких
инкапсулированных объектов, количество ссылок на эти объекты (для быстрого доступа к
ним) растёт взрывными темпами, а значит падает производительность.
</details>

<details>
  <summary>4. Назовите основные принципы ООП.</summary>

Объектно-ориентированное программирование обладает рядом принципов (ПАНИ)
- Полиморфизм
- Абстракция
- Наследование
- Инкапсуляция
</details>

<details>
  <summary>5. Что такое инкапсуляция? (c примером)</summary>

**Инкапсулируем, т.е. прячем данные и методы объекта в
классе, скрываем детали реализации от пользователя.
Открываем только то, что нужно при последующем
использовании (нужен ордер, а как реализован – скрыто).**

    Order order = getOrder();
    order.paymentReceived();
    order.sendToDelivery();
    order.cancel();

Использование инкапсуляции гарантирует, что данные не
будут искажены или изменены не надлежащим образом.

Очевидные примеры инкапсуляции:
- это модификаторы доступа (private, дефолт, protected, public)
- это класс, внутри которого описываем детали, используем далее везде
- на более высоком уровне, чем класс – это доступ на уровне пакета
- это также геттеры-сеттеры

**Пример**: если поле age у класса User не инкапсулировать, любой сможет написать: `User.age = -1000;` (минус тысяча)
Механизм инкапсуляции позволяет защитить поле age при помощи метода-сеттера, в который можно поместить проверку
(возраст не может быть отрицательным числом).
</details>

<details>
  <summary>6. Что такое наследование? (c примером)</summary>

**Наследование — это возможность порождать один класс от другого с сохранением всех
свойств и методов класса-предка (суперкласса), добавляя при необходимости новые
свойства и методы.**

    public final class BigDecimal extends Number {
        public int intValue() {
            // ...
        }
        // no shortValue() method,
        // it's inherited from Number
    }
    bd.intValue    bd.shortValue

Наследование позволяет реализовывать сложные схемы с четкой иерархией «от общего
к частному». Это облегчает понимание и масштабирование кода.

Зачем? Чтобы повторно использовать код.
Расширять функционал уже имеющихся
классов за счет добавления нового
функционала или изменения старого.

**Пример**: метод intValue() определён в классе BigDecimal,
метод shortValue() объявлен в его родительском классе
Number. Имея на руках экземпляр класса BigDecimal bd, мы
можем вызывать на нём как intValue(), так и shortValue().

**Работа с методами будет одинакова вне зависимости от уровня в иерархии
наследования.**

Наследование может быть одиночным и множественным (наследование одного класса
сразу от нескольких других). **_Множественное наследование запрещено в Java!_**

В качестве альтернативы абстрактному методу (где все методы публичные и
абстрактные), **в Java введена отдельная сущность – интерфейс** (по определению
методы публичные и абстрактные, поэтому явно писать данные модификаторы не нужно).

    Например, имеется следующий класс Person , описывающий отдельного человека:
    
    class Person {
        String name;
        public String getName() {
            return name;
        }
        public Person(String name) {
            this.name = name;
        }
    
        public void display() {
            System.out.println("Name: " + name);
        }
    }
    
    class Employee extends Person {
        public Employee(String name) {
            super(name); // если базовый класс определяет конструктор
                         // то производный класс должен его вызвать
        }
    }

Например, класс **Person**, человек.
И поскольку сотрудник – это также человек, то рационально сделать класс **Employee**
производным (наследником, подклассом) от класса Person, который, в свою очередь,
называется базовым классом, родителем или суперклассом.

Чтобы объявить один класс наследником от другого, надо использовать после имени
класса-наследника **ключевое слово _extends_**, после которого идет имя базового класса.

Если в базовом классе определены конструкторы, то в конструкторе производного класса
нужно вызвать один из конструкторов базового класса с помощью ключевого слова **_super_**.

**Справка**: _Указатель super - представляет экземпляр суперкласса. В подклассе можем напрямую обращаться к свойствам и методам, унаследованным от родительского класса, но, если свойства или методы подкласса имеют одинаковое имя (затенение атрибутов, переопределение метода), их необходимо различать, прежде чем к ним можно будет получить доступ._

_Между атрибутами с одним и тем же именем родительского и дочернего классов не существует переопределяющей связи, и одновременно существуют два пробела (дочерние классы охватывают свойства родительского класса), и для доступа необходимо использовать разные префиксы._

    class A {
        int value = 10;
    }
    
    class B extends A {
        int value = 20;
        public void print() {
            int value = 30;
            System.out.println(value);        // 30
            System.out.println(this.value);   // 20
            System.out.println(super.value);  // 10
        }
    }

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>


</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

</details>
